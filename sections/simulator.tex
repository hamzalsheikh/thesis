\section{Simulator}
The current intuition is adding an extra layer 
of scheduling when the cluster is over-subscribed \cite{zaharia_delay_2010}, 
but the mechanism can also be implemented as an additional step in the scheduling process. 
A simulation is being built to serve as a starting point \cite{sched-github}, 
and we plan to build the project on top of Kubernetes.

I've implemented a simulation to try to mimic the how clusters can interact and test some of the policies. 
The implementation is in Go. The end goal of the simulation is the ability to deploy clusters on different 
nodes/containers and test policies.

\subsection{Components}
\subsubsection{Registry}
The registry tracks the availability of the schedulers, and informs clusters with it. 
This gives visibility for schedulers who need to borrow resources. 
The actual implementation should be closer to a subscription service, 
were clusters agree to participate in the market. The registry itself is not a main 
component for the actual implementation, but if we end up with a policy that needs a control service, 
or a shared resource, the registry in the simulation will play this role.


\subsubsection{Scheduler}
The scheduler is built with a cluster as a resource attached to it. 
This can also be decoupled and a scheduler can exist as a standalone node. 
The current basic implementation have the scheduler receive job requests through http requests. 
Jobs have static memory and CPU requirements and time to complete. If not enough resources 
are found on the cluster then a policy is invoked for borrowing/lending.