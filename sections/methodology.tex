% This section does not mention the possibility of applying the mechanism to clusters of different organizations
\section{Methodology}
\vspace{1em}
\fbox{
    \begin{minipage}{33em}
\textbf{Thesis Statement:}
In a multi-cluster architecture, it is possible to increase cluster resource utilization, 
decrease average job completion time, and/or reduce average cost by 
providing clusters with a resource trading mechanism and a pluggable policy interface allowing the 
virtual sharing of resources across clusters.
   \end{minipage}
}

% Concept introduction
% Do not communicate by sharing memory           ; instead, share memory    by communicating.
% Do not communicate by changing server ownership; instead, share resources by communicating.
\vspace{1em}
% I don't want to mention capacity or whatever need because that is policy dependent
When needed, a cluster communicates with other clusters visible to it, requesting to use resources. A policy 
controls when a cluster requests those resources and when other clusters accept providing them. 
A simple example to that is in the Lyra system, were the requester's (training cluster) policy is request 
when cluster is over-subscribed, and the receiver's (inference cluster) policy is accept when 
utilization is below 98\% \cite{li_lyra_2023}. The trading mechanism is what allows clusters to use each others 
resources without forfeiting ownership of their resources. 

% show system novelty without direct comparison
Our mechanism offers bidirectional trading, allowing clusters to trade resources with one another. It also 
enables trading with multiple clusters, so clusters can trade resources with more than one cluster at a time. 
Policies are created to optimize a specific performance metric, acting as knobs to 
tune the mechanism and update it as cluster requirements change. They are a set of rules that dictate how each 
cluster handles trading.

The following algorithms show a simple representation of the system: \label{example}

% Example Algorithm
\begin{algorithm}[H]
\caption{Trading Scheduling Algorithm - Requester}
\begin{algorithmic}
    \For{job in WaitQueue}
        \State $scheduled \gets ScheduleJob(job)$
        \If{$scheduled \neq True$ \&\& Policy(job) $==$ True}  \Comment{P: True if waitQueue $> 10$}
        \State $requestResources(job)$
        \EndIf
    \EndFor

    \For{job in ReadyQueue}
        \State $scheduled \gets ScheduleJob(job)$
        \If{$scheduled \neq True$}
        \State $WaitQueue \gets WaitQueue + job$
        \EndIf
    \EndFor
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \caption{Trading Scheduling Algorithm - Receiver}
    \begin{algorithmic}
            \State $ resources \gets BorrowRequest $ \Comment{request from another cluster} 
            \If{$Policy(resources) = True$} \Comment{ P: True if utilization $\leq 80\%$}
            \State $sendAcceptRequest(job, cluster)$
            \State $prepareResources(resources)$
            \State $allowAccess$
            \EndIf
    \end{algorithmic}
\end{algorithm} 

Similar to delay scheduling \cite{zaharia_delay_2010}, the scheduler tries to schedule jobs locally first, and 
expands options gradually. 

The requester consults its policy when it couldn't schedule the job the second time and onwards, and the receiver 
accepts requests based on its policy too. Since the policies are pluggable, requester can reduce 
the minimum number of jobs in the waitQueue to make the policy more aggressive, 
or the receiver can increase utilization percentage for more stringent measures.

Another policy example would be trying to request higher performing resources than the one locally available 
to reduce JCT.

And lastly, for cost reduction, a policy would entail requesting resources that are cheaper on other clusters, where 
clusters can borrow and lend their resources for a token/dollar equivalence.